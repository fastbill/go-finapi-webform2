/*
finAPI Web Form 2.0

The following pages give you some general information on how to use our APIs.<br/>The actual API services documentation then follows further below. You can use the menu to jump between API sections.<br/><br/>This page has a built-in HTTP(S) client, so you can test the services directly from within this page, by filling in the request parameters and/or body in the respective services, and then hitting the TRY button. Note that you need to be authorized to make a successful API call. To authorize, refer to the '<a target='_blank' href='https://docs.finapi.io/?product=access#tag--Authorization'>Authorization</a>' section of Access, or in case you already have a valid user token, just use the QUICK AUTH on the left.<br/>Please also remember that all user management functions should be looked up in <a target='_blank' href='https://docs.finapi.io/?product=access'>Access</a>.<br/><br/>You should also check out the <a target='_blank' href='https://documentation.finapi.io/webform/'>Web Form 2.0 Public Documentation</a> as well as <a target='_blank' href='https://documentation.finapi.io/access/'>Access Public Documentation</a> for more information. If you need any help with the API, contact <a href='mailto:support@finapi.io'>support@finapi.io</a>.<br/><h2 id=\"general-information\">General information</h2><h3 id=\"general-request-ids\"><strong>Request IDs</strong></h3>With any API call, you can pass a request ID via a header with name \"X-Request-Id\". The request ID can be an arbitrary string with up to 255 characters. Passing a longer string will result in an error.<br/><br/>If you don't pass a request ID for a call, finAPI will generate a random ID internally.<br/><br/>The request ID is always returned back in the response of a service, as a header with name \"X-Request-Id\".<br/><br/>We highly recommend to always pass a (preferably unique) request ID, and include it into your client application logs whenever you make a request or receive a response(especially in the case of an error response). finAPI is also logging request IDs on its end. Having a request ID can help the finAPI support team to work more efficiently and solve tickets faster.<h3 id=\"type-coercion\"><strong>Type Coercion</strong></h3>In order to ease the integration for some languages, which do not natively support high precision number representations, Web Form 2.0 API supports relax type binding for the openAPI type <code>number</code>, which is used for money amount fields. If you use one of those languages, to avoid precision errors that can appear from <code>float</code> values, you can pass the amount as a <code>string</code>.<h3 id=\"general-faq\"><strong>FAQ</strong></h3><strong>Is there a finAPI SDK?</strong><br/>Currently we do not offer a native SDK, but there is the option to generate an SDKfor almost any target language via OpenAPI. Use the 'Download SDK' button on this page for SDK generation.<br/><br/><strong>Why do I need to keep authorizing when calling services on this page?</strong><br/>This page is a \"one-page-app\". Reloading the page resets the OAuth authorization context. There is generally no need to reload the page, so just don't do it and your authorization will persist.

API version: 2.430.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package webform2

import (
	"encoding/json"
	"fmt"
)

// WebFormStatus <strong>Web form status:</strong><br/>&bull; <code>NOT_YET_OPENED</code> - the web form was not yet opened by the end user;<br/>&bull; <code>IN_PROGRESS</code> - the web form has already been opened by the end user and is currently in progress;<br/>&bull; <code>COMPLETED</code> - the web form has been successfully completed (final status);<br/>&bull; <code>COMPLETED_WITH_ERROR</code> - the web form has been completed with an error (final status);<br/>&bull; <code>EXPIRED</code> - the web form has expired (final status);<br/>&bull; <code>ABORTED</code> - the web form has been cancelled by the end user (final status).
type WebFormStatus string

// List of WebFormStatus
const (
	WEBFORMSTATUS_NOT_YET_OPENED WebFormStatus = "NOT_YET_OPENED"
	WEBFORMSTATUS_IN_PROGRESS WebFormStatus = "IN_PROGRESS"
	WEBFORMSTATUS_COMPLETED WebFormStatus = "COMPLETED"
	WEBFORMSTATUS_COMPLETED_WITH_ERROR WebFormStatus = "COMPLETED_WITH_ERROR"
	WEBFORMSTATUS_EXPIRED WebFormStatus = "EXPIRED"
	WEBFORMSTATUS_ABORTED WebFormStatus = "ABORTED"
)

// All allowed values of WebFormStatus enum
var AllowedWebFormStatusEnumValues = []WebFormStatus{
	"NOT_YET_OPENED",
	"IN_PROGRESS",
	"COMPLETED",
	"COMPLETED_WITH_ERROR",
	"EXPIRED",
	"ABORTED",
}

func (v *WebFormStatus) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := WebFormStatus(value)
	for _, existing := range AllowedWebFormStatusEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid WebFormStatus", value)
}

// NewWebFormStatusFromValue returns a pointer to a valid WebFormStatus
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewWebFormStatusFromValue(v string) (*WebFormStatus, error) {
	ev := WebFormStatus(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for WebFormStatus: valid values are %v", v, AllowedWebFormStatusEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v WebFormStatus) IsValid() bool {
	for _, existing := range AllowedWebFormStatusEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to WebFormStatus value
func (v WebFormStatus) Ptr() *WebFormStatus {
	return &v
}

type NullableWebFormStatus struct {
	value *WebFormStatus
	isSet bool
}

func (v NullableWebFormStatus) Get() *WebFormStatus {
	return v.value
}

func (v *NullableWebFormStatus) Set(val *WebFormStatus) {
	v.value = val
	v.isSet = true
}

func (v NullableWebFormStatus) IsSet() bool {
	return v.isSet
}

func (v *NullableWebFormStatus) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableWebFormStatus(val *WebFormStatus) *NullableWebFormStatus {
	return &NullableWebFormStatus{value: val, isSet: true}
}

func (v NullableWebFormStatus) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableWebFormStatus) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}

